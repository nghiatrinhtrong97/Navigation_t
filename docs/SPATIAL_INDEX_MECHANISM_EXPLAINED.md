# Gi·∫£i Th√≠ch C∆° Ch·∫ø Spatial Index Query

**T√†i li·ªáu:** C√°ch th·ª©c ho·∫°t ƒë·ªông c·ªßa R-tree Spatial Index trong Geocoding  
**Ng√†y:** 19/10/2025

---

## üéØ V·∫§N ƒê·ªÄ C·∫¶N GI·∫¢I QUY·∫æT

### C√¢u h·ªèi:
> "T·ª´ address ƒë∆∞·ª£c chu·∫©n h√≥a t√¨m ra tile trong spatial ki·ªÉu g√¨?"

### Tr·∫£ l·ªùi ng·∫Øn g·ªçn:
**KH√îNG d√πng tile! Spatial Index s·ª≠ d·ª•ng R-tree (Rectangle-tree) ƒë·ªÉ t√¨m ƒë·ªãa ch·ªâ g·∫ßn nh·∫•t d·ª±a tr√™n T·ªåA ƒê·ªò ƒë·ªãa l√Ω (lat/lon), KH√îNG ph·∫£i t·ª´ chu·ªói text.**

---

## üèóÔ∏è KI·∫æN TR√öC SPATIAL INDEX

### 1. **C·∫•u tr√∫c d·ªØ li·ªáu: R*-tree**

R-tree l√† c·∫•u tr√∫c c√¢y c√¢n b·∫±ng ƒë·ªÉ index d·ªØ li·ªáu kh√¥ng gian (spatial data):

```
R-tree Structure:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Root Node                             ‚îÇ
‚îÇ  Bounding Box: (21.0¬∞N-23.5¬∞N, 105.0¬∞E-106.5¬∞E)        ‚îÇ ‚Üê To√†n b·ªô Vi·ªát Nam (v√πng r·ªông)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ                 ‚îÇ                    ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Node A  ‚îÇ    ‚îÇ  Node B    ‚îÇ      ‚îÇ  Node C    ‚îÇ
‚îÇ H√† N·ªôi  ‚îÇ    ‚îÇ  TP.HCM    ‚îÇ      ‚îÇ  ƒê√† N·∫µng   ‚îÇ        ‚Üê Chia theo v√πng
‚îÇ 21.0¬∞N  ‚îÇ    ‚îÇ  10.7¬∞N    ‚îÇ      ‚îÇ  16.0¬∞N    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îÇ                ‚îÇ                    ‚îÇ
    ‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îÇ
    ‚îÇ         ‚îÇ             ‚îÇ             ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇAddr 1 ‚îÇ  ‚îÇAddr2‚îÇ    ‚îÇ Addr 3 ‚îÇ    ‚îÇ Addr 4 ‚îÇ          ‚Üê Leaf nodes (ƒë·ªãa ch·ªâ c·ª• th·ªÉ)
‚îÇ21.028¬∞‚îÇ  ‚îÇ21.03¬∞‚îÇ   ‚îÇ 10.77¬∞ ‚îÇ    ‚îÇ 16.05¬∞ ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

M·ªói node l∆∞u:
- Bounding Box (minLat, maxLat, minLon, maxLon)
- Con tr·ªè ƒë·∫øn c√°c node con ho·∫∑c ƒë·ªãa ch·ªâ
```

### 2. **AddressRecord - D·ªØ li·ªáu trong Index**

```cpp
struct AddressRecord {
    uint64_t id;                      // ID duy nh·∫•t: 12345
    Point location;                   // ‚òÖ QUAN TR·ªåNG: {lat: 21.028511, lon: 105.804817}
    std::string formatted_address;    // "123 Ph·ªë Hu·∫ø, Hai B√† Tr∆∞ng, H√† N·ªôi"
    std::string normalized_address;   // "123 PHO HUE HAI BA TRUNG HA NOI"
    std::string postal_code;          // "100000"
    std::string city;                 // "H√† N·ªôi"
    std::string state;                // "Vietnam"
    
    // Metadata
    std::string data_source;          // "POI_DB" ho·∫∑c "TIGER", "OSM"
    GeocodingQuality quality;         // STREET_LEVEL (¬±10m)
    uint64_t last_updated_ms;         // 1697702400000
};
```

**CH√ö √ù:** 
- `location` (lat/lon) l√† **KEY** ƒë·ªÉ build R-tree
- `formatted_address` ch·ªâ d√πng ƒë·ªÉ **hi·ªÉn th·ªã k·∫øt qu·∫£**, KH√îNG d√πng ƒë·ªÉ search

---

## üîç QUY TR√åNH GEOCODING V·ªöI SPATIAL INDEX

### **B∆Ø·ªöC 1: Parse & Normalize Address (Text Processing)**

**Input (User):**
```
"123 ph·ªë hu·∫ø, h√† n·ªôi"
```

**Output (AddressComponents):**
```cpp
AddressComponents parsed = {
    house_number: "123",
    street_name: "Ph·ªë Hu·∫ø",
    city: "H√† N·ªôi",
    state: "Vietnam",
    postal_code: null,  // Kh√¥ng c√≥ trong input
    country: "VN"
};
```

**Code:**
```cpp
// File: poi_service.cpp, Line 337-342
geocoding::AddressParser parser;
geocoding::AddressComponents parsed_components = 
    parser.parse(request.freeform_address, request.country_code);

geocoding::AddressNormalizer normalizer;
geocoding::AddressComponents normalized_components = 
    normalizer.normalize(parsed_components);
```

---

### **B∆Ø·ªöC 2: Estimate Location (Text ‚Üí Coordinates)**

**‚ö†Ô∏è ƒê√ÇY L√Ä B∆Ø·ªöC QUAN TR·ªåNG NH·∫§T!**

V√¨ R-tree ch·ªâ l√†m vi·ªác v·ªõi **T·ªåA ƒê·ªò** (lat/lon), ta ph·∫£i **∆Ø·ªöC T√çNH** t·ªça ƒë·ªô t·ª´ text!

#### **Chi·∫øn l∆∞·ª£c ∆∞·ªõc t√≠nh:**

**A. N·∫øu c√≥ Postal Code (M√£ b∆∞u ch√≠nh):**
```cpp
// Line 496-499
if (normalized_address.postal_code.has_value()) {
    // Tra c·ª©u centroid (t√¢m v√πng) t·ª´ database ZIP code
    estimated_center = zipCodeDatabase.lookup("100000");
    // ‚Üí K·∫øt qu·∫£: {lat: 21.0285, lon: 105.8542} (trung t√¢m H√† N·ªôi)
}
```

**B. N·∫øu c√≥ City/State:**
```cpp
// Tra c·ª©u t·ªça ƒë·ªô trung t√¢m th√†nh ph·ªë
if (normalized_address.city.has_value()) {
    estimated_center = cityDatabase.lookup("H√† N·ªôi");
    // ‚Üí K·∫øt qu·∫£: {lat: 21.0285, lon: 105.8542}
}
```

**C. N·∫øu User cung c·∫•p Reference Location:**
```cpp
// Line 501-503
if (request.reference_location.has_value()) {
    estimated_center = *request.reference_location;
    // V√≠ d·ª•: GPS hi·ªán t·∫°i c·ªßa user {lat: 21.030, lon: 105.850}
}
```

**D. Fallback - D√πng centroid qu·ªëc gia:**
```cpp
// Default cho Vi·ªát Nam
estimated_center = {lat: 16.0, lon: 108.0};
```

---

### **B∆Ø·ªöC 3: Query Spatial Index (Geographic Search)**

#### **3.1. Query by k-Nearest Neighbors (k-NN)**

**M·ª•c ƒë√≠ch:** T√¨m k ƒë·ªãa ch·ªâ **G·∫¶N NH·∫§T** v·ªõi t·ªça ƒë·ªô ∆∞·ªõc t√≠nh.

**Code:**
```cpp
// Line 505-508
auto candidates = m_spatialIndex->findNearestAddresses(
    estimated_center,    // {lat: 21.028, lon: 105.850}
    request.max_results  // k = 10
);
```

**C∆° ch·∫ø R-tree k-NN (trong spatial_index.cpp, Line 235-263):**

```cpp
// 1. D√πng Boost.Geometry R-tree built-in k-NN query
BoostPoint query_point = toBoostPoint(estimated_center);
std::vector<RTreeValue> nearest;

m_impl->rtree->query(
    bgi::nearest(query_point, k),  // ‚Üê T√¨m k nearest neighbors
    std::back_inserter(nearest)
);

// 2. T√≠nh kho·∫£ng c√°ch ch√≠nh x√°c (Haversine formula)
std::vector<std::pair<AddressRecord, double>> scored;
for (const auto& value : nearest) {
    const AddressRecord& addr = value.second;
    double distance = calculateDistance(estimated_center, addr.location);
    scored.emplace_back(addr, distance);
}

// 3. S·∫Øp x·∫øp theo kho·∫£ng c√°ch tƒÉng d·∫ßn
std::sort(scored.begin(), scored.end(),
    [](const auto& a, const auto& b) { return a.second < b.second; });
```

**V√≠ d·ª• k·∫øt qu·∫£:**
```
estimated_center: {lat: 21.028, lon: 105.850}

Candidates (top 10 nearest):
1. "120 Ph·ªë Hu·∫ø, Hai B√† Tr∆∞ng" ‚Üí distance = 50m
2. "123 Ph·ªë Hu·∫ø, Hai B√† Tr∆∞ng" ‚Üí distance = 85m  ‚Üê ‚òÖ Match!
3. "125 Ph·ªë Hu·∫ø, Hai B√† Tr∆∞ng" ‚Üí distance = 120m
4. "100 Ph·ªë Hu·∫ø, Hai B√† Tr∆∞ng" ‚Üí distance = 200m
5. "150 Tr·∫ßn Nh√¢n T√¥ng, Hai B√† Tr∆∞ng" ‚Üí distance = 300m
...
```

#### **3.2. Ho·∫∑c Query by Radius (T√¨m trong b√°n k√≠nh)**

**Code:**
```cpp
auto candidates = m_spatialIndex->queryRadius(
    estimated_center,  // {lat: 21.028, lon: 105.850}
    1000.0            // radius = 1km (1000 meters)
);
```

**C∆° ch·∫ø trong spatial_index.cpp (Line 172-214):**

```cpp
// 1. Convert radius to degrees (approximate)
double radius_degrees = radius_meters / 111000.0;  // 1 degree ‚âà 111km

// 2. Create bounding box for initial filter
BoundingBox bbox;
bbox.minLat = center.latitude - radius_degrees;
bbox.maxLat = center.latitude + radius_degrees;
bbox.minLon = center.longitude - radius_degrees;
bbox.maxLon = center.longitude + radius_degrees;

// 3. Query R-tree for candidates in bounding box
auto candidates = queryRegion(bbox);

// 4. Filter by exact geodetic distance (Haversine)
for (const auto& addr : candidates) {
    double distance = calculateDistance(center, addr.location);
    if (distance <= radius_meters) {
        results.push_back(addr);
    }
}
```

**H√¨nh ·∫£nh minh h·ªça:**
```
        Bounding Box (initial filter)
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                         ‚îÇ
        ‚îÇ      ‚óã  ‚óã               ‚îÇ ‚Üê Candidates in box
        ‚îÇ    ‚óã   ‚óè   ‚óã            ‚îÇ   (fast R-tree query)
        ‚îÇ      ‚óã  ‚óã  ‚óã            ‚îÇ
        ‚îÇ                         ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚ñº
        Apply exact distance filter
                 ‚îÇ
                 ‚ñº
           Results within 1km
              ‚óã  ‚óè  ‚óã
               (sorted)
```

---

### **B∆Ø·ªöC 4: String Matching & Ranking (Text Comparison)**

**Sau khi c√≥ candidates t·ª´ spatial index, so s√°nh string:**

```cpp
// Simplified example
std::string input_normalized = "123 PHO HUE";
double best_score = 0.0;
AddressRecord best_match;

for (const auto& candidate : candidates) {
    // Compare normalized strings
    double score = calculateStringSimilarity(
        input_normalized, 
        candidate.normalized_address
    );
    
    // Adjust score by distance (closer = better)
    double distance_penalty = 1.0 - (distance / 1000.0);
    double final_score = score * 0.7 + distance_penalty * 0.3;
    
    if (final_score > best_score) {
        best_score = final_score;
        best_match = candidate;
    }
}
```

---

## üìä SO S√ÅNH: LINEAR SEARCH vs SPATIAL INDEX

### **Scenario: T√¨m ƒë·ªãa ch·ªâ trong database 100,000 POIs**

#### **1. Linear Search (Kh√¥ng d√πng Spatial Index):**

```cpp
// C√°ch c≈©: Brute-force
std::vector<POI> results;
for (const auto& poi : m_poiDatabase) {  // 100,000 iterations
    if (poi.address.contains("Ph·ªë Hu·∫ø")) {
        double distance = calculateDistance(reference, poi.location);
        results.push_back({poi, distance});
    }
}
std::sort(results.begin(), results.end());
```

**Performance:**
- **Time complexity:** O(n) = 100,000 comparisons
- **Time:** ~50-100ms cho m·ªói query
- **Scalability:** T·ªá (1M addresses ‚Üí 500ms+)

---

#### **2. Spatial Index (R-tree):**

```cpp
// C√°ch m·ªõi: Spatial query
auto candidates = m_spatialIndex->findNearestAddresses(
    estimated_center, 10  // Ch·ªâ c·∫ßn 10 candidates
);
// ‚Üí Only ~50-100 nodes visited in tree (not 100,000!)
```

**Performance:**
- **Time complexity:** O(log n) = ~15-20 node visits
- **Time:** ~5-10ms cho m·ªói query
- **Scalability:** T·ªët (1M addresses ‚Üí still ~10-15ms)

---

## üîß CHI TI·∫æT K·ª∏ THU·∫¨T R-TREE

### **1. Build Index (spatial_index.cpp, Line 95-128)**

```cpp
bool SpatialIndex::buildIndex(const std::vector<AddressRecord>& addresses) {
    // 1. Convert AddressRecord ‚Üí RTreeValue (Boost type)
    std::vector<RTreeValue> values;
    for (const auto& addr : addresses) {
        BoostPoint point(addr.location.longitude, addr.location.latitude);
        values.emplace_back(point, addr);  // (geometry, payload)
    }
    
    // 2. Bulk load R-tree (faster than incremental insert)
    m_impl->rtree = std::make_unique<RTree>(values.begin(), values.end());
    // ‚Üí Automatically builds balanced tree
    
    return true;
}
```

**Tree Structure After Build:**
```
Depth 0 (Root):    [Vietnam: 8¬∞N-24¬∞N, 102¬∞E-110¬∞E]
                            |
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        |                   |                    |
Depth 1:  [North Vietnam]  [Central]      [South Vietnam]
        21¬∞-24¬∞N         15¬∞-18¬∞N           8¬∞-12¬∞N
            |                |                  |
        ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê
Depth 2: [Hanoi] [HaiPhong] [DaNang] [Hue] [HCM] [CanTho]
            |
        ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê
Depth 3: [District 1] [District 2] ...
            |
        ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê
Depth 4: [Street 1] [Street 2] ...
            |
Leaf:    [Address 1] [Address 2] [Address 3] ...
```

### **2. Query Algorithm (Boost.Geometry bgi::nearest)**

**Pseudocode:**
```python
def find_k_nearest(query_point, k):
    priority_queue = []
    visited_nodes = []
    
    # 1. Start from root
    current = root_node
    
    # 2. Traverse tree (depth-first with backtracking)
    while len(results) < k or priority_queue.not_empty():
        if current.is_leaf():
            # Calculate distance to actual addresses
            for addr in current.addresses:
                dist = haversine(query_point, addr.location)
                priority_queue.push((dist, addr))
        else:
            # Calculate distance to child bounding boxes
            for child in current.children:
                min_dist = distance_to_bbox(query_point, child.bbox)
                priority_queue.push((min_dist, child))
        
        # 3. Pop next closest node/address
        current = priority_queue.pop()
    
    # 4. Return top k
    return priority_queue.top(k)
```

**V√≠ d·ª• trace:**
```
Query: Find 3 nearest to {21.028¬∞N, 105.850¬∞E}

Step 1: Start at Root
  ‚Üí Visit child bounding boxes
  ‚Üí North Vietnam (distance = 0km) ‚Üê Contains query point
  ‚Üí Central (distance = 500km)
  ‚Üí South (distance = 1200km)
  ‚Üí Priority: [North(0), Central(500), South(1200)]

Step 2: Visit North Vietnam
  ‚Üí Visit child boxes
  ‚Üí Hanoi (distance = 0km)
  ‚Üí Hai Phong (distance = 80km)
  ‚Üí Priority: [Hanoi(0), HaiPhong(80), Central(500), ...]

Step 3: Visit Hanoi districts
  ‚Üí Hai B√† Tr∆∞ng (distance = 0km)
  ‚Üí Ho√†n Ki·∫øm (distance = 2km)
  ‚Üí Priority: [HaiBaTrung(0), HoanKiem(2), HaiPhong(80), ...]

Step 4: Visit Hai B√† Tr∆∞ng streets
  ‚Üí Ph·ªë Hu·∫ø (distance = 0km)
  ‚Üí Tr·∫ßn Nh√¢n T√¥ng (distance = 0.3km)
  ‚Üí Priority: [PhoHue(0), TranNhanTong(0.3), HoanKiem(2), ...]

Step 5: Visit addresses on Ph·ªë Hu·∫ø
  ‚Üí 120 Ph·ªë Hu·∫ø (distance = 50m)
  ‚Üí 123 Ph·ªë Hu·∫ø (distance = 85m) ‚Üê TARGET!
  ‚Üí 125 Ph·ªë Hu·∫ø (distance = 120m)

Step 6: Return top 3
  ‚Üí Results: [120(50m), 123(85m), 125(120m)]
```

**Nodes visited:** ~5-7 (not 100,000!)

---

## üéØ T√ìM T·∫ÆT C∆† CH·∫æ

### **C√¢u h·ªèi ban ƒë·∫ßu:**
> "T·ª´ address ƒë∆∞·ª£c chu·∫©n h√≥a t√¨m ra tile trong spatial ki·ªÉu g√¨?"

### **Tr·∫£ l·ªùi chi ti·∫øt:**

1. **KH√îNG d√πng "tile"** (nh∆∞ Google Maps tiles, OSM tiles)
   - R-tree d√πng **bounding boxes** (h√¨nh ch·ªØ nh·∫≠t), kh√¥ng ph·∫£i tiles

2. **KH√îNG t√¨m tr·ª±c ti·∫øp t·ª´ text**
   - R-tree ch·ªâ l√†m vi·ªác v·ªõi **t·ªça ƒë·ªô** (lat/lon)
   - Text ch·ªâ d√πng ƒë·ªÉ **∆∞·ªõc t√≠nh t·ªça ƒë·ªô** ban ƒë·∫ßu

3. **Quy tr√¨nh th·ª±c t·∫ø:**
   ```
   Text "123 Ph·ªë Hu·∫ø, H√† N·ªôi"
       ‚Üì (Parse & Normalize)
   Components {street: "Ph·ªë Hu·∫ø", city: "H√† N·ªôi"}
       ‚Üì (Estimate Location)
   Coordinates {lat: 21.028, lon: 105.850}
       ‚Üì (Query R-tree)
   k-Nearest Neighbors [addr1, addr2, addr3, ...]
       ‚Üì (String Matching)
   Best Match: "123 Ph·ªë Hu·∫ø" (score: 0.95)
   ```

4. **Key insight:**
   - **Input:** Text (string)
   - **Query:** Coordinates (lat/lon) ‚Üê **Conversion happens here!**
   - **Output:** Addresses with locations
   - **Ranking:** String similarity + distance

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### **Files trong project:**
- `hmi/services/geocoding/include/spatial_index.h` - Interface
- `hmi/services/geocoding/src/spatial_index.cpp` - Implementation
- `hmi/services/poi/src/poi_service.cpp` (Line 491-545) - Usage

### **Libraries:**
- **Boost.Geometry R-tree:** https://www.boost.org/doc/libs/1_83_0/libs/geometry/doc/html/geometry/reference/spatial_indexes/boost__geometry__index__rtree.html
- **R-tree paper:** Guttman, A. (1984). "R-trees: A Dynamic Index Structure for Spatial Searching"

### **Algorithms:**
- **Haversine formula:** Calculate great-circle distance between two lat/lon points
- **k-NN (k-Nearest Neighbors):** Find k closest points in spatial data
- **Bounding box:** Rectangular region defined by (minLat, maxLat, minLon, maxLon)

---

**T√°c gi·∫£:** GitHub Copilot  
**Ng√†y:** 19/10/2025  
**Version:** 1.0
